package pt.isel.SHORT

import pt.isel.SHORT.html.attribute.charset
import pt.isel.SHORT.html.attribute.href
import pt.isel.SHORT.html.attribute.id
import pt.isel.SHORT.html.attribute.rel
import pt.isel.SHORT.html.attribute.src
import pt.isel.SHORT.html.attribute.type
import pt.isel.SHORT.html.base.Body
import pt.isel.SHORT.html.base.Head
import pt.isel.SHORT.html.base.Html
import pt.isel.SHORT.html.base.Script
import pt.isel.SHORT.html.base.attribute.Attribute
import pt.isel.SHORT.html.base.css.Import
import pt.isel.SHORT.html.base.element.Tag
import pt.isel.SHORT.html.element.Link
import pt.isel.SHORT.html.element.Meta
import pt.isel.SHORT.html.element.Template
import java.lang.reflect.Method
import kotlin.reflect.jvm.kotlinFunction

/**
 * This annotation is used to represent a page in the web application
 */
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION)
annotation class Page(val path: String)

/**
 * This represents the functions that generate pages
 */
typealias PageFactory = Method

/**
 * Generates a [WebApp] from the functions annotated with [Page]
 * @return a [WebApp] with a single page that contains the whole single page application
 */
fun generateWebApp(application: Application): WebApp {
    val classNames = ClassManager.searchClasses("")
    return aggregatePages(application, getPages(classNames))
}

/**
 * Converts the list of class names into a list will the corresponding pages
 * @param [classNames] the [List] of [String] containing the names of the classes
 * @return the list of [PageFactory]
 */
fun getPages(classNames: List<String>): List<PageFactory> {
    return classNames.flatMap { className ->
        return@flatMap try {
            Class.forName(className).methods.filter { m ->
                m.isAnnotationPresent(Page::class.java)
            }.map { page ->
                if (page.returnType == Tag::class.java) {
                    page
                } else {
                    throw PageNotFoundException("Method ${page.name} does not return a HtmlPage")
                }
            }
        } catch (e: Exception) {
            when (e) {
                is ClassNotFoundException -> {
                    throw ClassNotFoundException("Class not found: $className", e)
                }
                else -> throw e
            }
        }
    }.filterNotNull()
}

/**
 * Aggregates the pages into a single page
 * @param [pages] the list of pages
 * @return the single page
 */
fun aggregatePages(application: Application, pages: List<PageFactory>): Html {
    return Html(application) {
        Head {
            Meta(attributes = Attribute.charset("UTF-8"))
            Script(attributes = Attribute.src("/scripts/router.js"))
            Script(attributes = Attribute.src("/scripts/requester.js"))

            val imports = pages.flatMap { page ->
                // This script is generated by the server
                val url = page.getAnnotation(Page::class.java)?.path
                    ?: throw PageLinkageException("Failed to link '${page.name}' to a path.")
                Template(Attribute.id("page-$url")) {
                    page.kotlinFunction!!.call(this)
                }
                return@flatMap page.getAnnotationsByType(Import::class.java).toList()
            }

            imports
                .distinct()
                .forEach { import ->
                    val attributes = Attribute.type(import.type).href(import.path)
                    val finalAttributes = if (import.relation.isNotBlank()) {
                        attributes.rel(import.relation)
                    } else {
                        attributes
                    }
                    Link(finalAttributes)
                }
            // Register all event handlers
            Script {
                append(scope.eventHandlersToHtml())
            }
            // Global script (used to log server errors on tag.toHtml function)
            Script {
                append("/*Global script*/")
                append(scope.globalScript.toHtml())
            }
            Script {
                append("/*Variables*/")
                append(scope.variablesToHtml())
            }
        }
        Body()
    }
}
