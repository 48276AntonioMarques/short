package pt.isel.SHORT

import pt.isel.SHORT.html.Html
import pt.isel.SHORT.html.HtmlPage
import pt.isel.SHORT.html.HtmlTag
import pt.isel.SHORT.html.Script
import pt.isel.SHORT.html.element.Body
import pt.isel.SHORT.html.element.Div
import pt.isel.SHORT.html.element.Head
import java.io.BufferedReader
import java.io.InputStreamReader
import java.lang.reflect.Method

@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION)
annotation class Page(val path: String)

typealias PageFactory = Method

fun generateWebApp(): WebApp {
    // Generate the base web page with client routing and server requester
    // Search for all the page notations

    val webApp = aggregatePages(getPages())
    return webApp.toHtml()
}

fun ClassLoader.searchClasses(packageName: String): List<String> {
    val classpath = packageName.replace(".", "/")
    if (packageName == "META-INF") return emptyList()
    val entries = mutableListOf<String>()
    val resourceStream = getResourceAsStream(classpath) ?: return emptyList()
    val resourceReader = BufferedReader(InputStreamReader(resourceStream))
    resourceReader.lines().forEach { entry ->
        // If is class file remove the .class extension and print it
        if (entry.endsWith(".class")) {
            entries += "$packageName.${entry.replace(".class", "")}"
        } else {
            val newPackage = if (packageName.isEmpty()) entry else "$packageName.$entry"
            entries += searchClasses(newPackage)
        }
        // If is a directory print it and run a recursive search
    }
    return entries
}

fun getPages(): List<PageFactory> {
    val sysClassLoader = ClassLoader.getSystemClassLoader()
    val classNames = sysClassLoader.searchClasses("")
    return classNames.flatMap { className ->
        return@flatMap try {
            Class.forName(className).methods.filter { m ->
                m.isAnnotationPresent(Page::class.java)
            }.map { page ->
                if (page.returnType == HtmlTag::class.java) {
                    page
                } else {
                    // TODO: Decide what to do when a method does not return a HtmlPage
                    println("Method ${page.name} does not return a HtmlTag")
                    null
                }
            }
        } catch (cnfe: ClassNotFoundException) {
            println("Class not found: $className")
            // TODO: Decide what to do when a class is not found
            return@flatMap emptyList()
        }
    }.filterNotNull()
}

fun aggregatePages(pages: List<PageFactory>): HtmlPage {
    return Html {
        Head {
            Script("/scripts/router.js")
            Script("/scripts/requester.js")
            pages.forEach { page ->
                // This script is generated by the server
                // And generates a function that sets the <div id="app"> to the page
                Script {
                    // TODO: Decide what to do when a page does not have a path
                    val url = page.getAnnotation(Page::class.java)?.path ?: "NULL"
                    println(page)
                    // val pageClass = page.javaClass.getConstructor().newInstance()
                    val pageInstance = page.invoke(page.javaClass) as HtmlTag
                    "registerPage(\"$url\", () => { return \"${pageInstance.toHtml()}\"})"
                }
            }
        }
        Body {
            Div(id = "app") {
            }
        }
        // TODO: Run client router when the page is loaded to load the correct page
        Script {
            "loadPage('/')"
        }
    }
}
